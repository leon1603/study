# -*- coding: utf-8 -*-
"""genomescale_fba_exercise_answers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OjurYibBe9mZ5rqiRhWgv0lzidkmfJLK
"""

import pandas as pd
import numpy as np
from scipy.optimize import linprog

"""If you are on Google Colab, upload both files (stoichiometry and constraints) using the files tab on the right.

We will load them now.
"""

stoichiometry = pd.read_csv('iAF1260_stoichiometry.csv', index_col=0)
constraints = pd.read_csv('iAF1260_constraints.csv', header=None, index_col=0)

"""You can inspect the files here if you wish:"""

stoichiometry

"""Following what we learned last week about implementing Flux Balance Analysis in python, we will create the missing vector **b** for our constain Ax=b.

We also create the objective vector, telling the program to optimize the production of biomass. Biomass production reactions is the 1005th column of the matix, you should verify this yourself.
"""

b = np.repeat(0,stoichiometry.shape[0])
objective = np.repeat(0,stoichiometry.shape[1])
objective[1004] = -1

"""
Now we make the following model:
max vgrowth                 Objective
Sv = 0                      b = np.repeat(0,stoichiometry.shape[0])
vmin ≤ v ≤ vmax:            Constraints

Now we can optimize our linear program using the *linprog* function as follows
"""

res = linprog(objective, A_eq = stoichiometry, b_eq = b, bounds = constraints)

"""Let's check the status of the optimization"""

res.status

"""Question: Look what this number means in [the official docummentation page](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html). Can we proceed with the analysis?

If we can procede, let's look at the value of the objective at the optimum point:
"""

res.fun
np.dot(np.transpose(objective), res.x) # Why the value is negative. You set the objective value at -1

"""Question: Why is this value negative?

    because you compute np.dot(np.transpose(objective), res.x)

Let's now look at value of the fluxes at optimal growth. Tip: you can click in the round button with a table icon to get access to the full table.
"""

fluxes_optim = pd.DataFrame(res.x,index = stoichiometry.columns)
fluxes_optim

"""Question: How many reactions have a non zero flux after maximising growth?"""

sum(res.x != 0)
# or (fluxes_optim.iloc[:, 0] !=0).sum()

"""# Reaction lethality

Let's now check the lethality of each reaction. We do this by knocking them out one by one individually, and calculating the optimum growth each time. If the optimum growth is 0 (or the program is infeasable), the cell cannot grow and we say that the knockout is lethal. Consult the syllabus for a better explanation of the process.

A knockout can be performed in a linear program by simply setting the upper and lower bounds of a reaction to 0.

## Coding exercise
Make a 'for loop' that loops trough all the reactions, and at each iteration set its bounds to zero and perform optimization for growth. Check the status of the optimization and the value of biomass production and save these values.

Now we make the following model:
max vgrowth                 Objective
Sv = 0                      b = np.repeat(0,stoichiometry.shape[0])
0 ≤ vi ≤ 0                  remove reactuion i
vmin ≤ v ≤ vmax:            Constraints (appreciatre that these are updated vor every vi)
"""
lethality = pd.Series(index = stoichiometry.columns)

for reaction in stoichiometry.columns: # loops through reactions
  new_constraints = constraints.copy()
  new_constraints.loc[reaction,:] = [0,0] # knocks out reaction
  optim = linprog(objective, A_eq = stoichiometry, b_eq = b, bounds = new_constraints, method='highs-ipm')
  if optim.status == 2: #infeasable
    lethality[reaction] = 'infeasable'
  else:
    lethality[reaction] = -optim.fun
  if optim.status == 2: #infeasable
    lethality[reaction] = 'infeasable'
  else:
    lethality[reaction] = -optim.fun

"""Let's analyze the results

1. List all the knockouts lead to zero growth (or an infeasable program)
2. How many knockouts were lethal?
3. Where all these reaction active (non zero flux) on the reference original simulation?
"""

lethal_idx = [x for x in lethality.index if lethality[x] in ['infeasable',0]]
print(len(lethal_idx))
any(fluxes_optim.loc[lethal_idx] == 0)

"""# Flux variability analysis

We will now perform a flux variability analysis. The end result of this analysis show be the maximal and minimal flux in each reaction that can still sustain maximum growth. Again consult the syllabus for a more indepth explanation.

To make sure that the growth is always at a maximum, we can set the bounds of the biomass reaction to be exactly that of the maximum previously calculated.

Insert the correct bounds below:
"""

constraints_max_growth = constraints.copy()
constraints_max_growth.loc['BIOMASS_Ec_iAF1260_core_59p81M',:] = [0.7367009388433972,0.7367009388433972]  # Edit here

"""## Coding exercise

We will then loop again trough all the reactions, and inside each loop we will both try to maximise and minimize the flux in the respective reaction, saving their values:
    
Now we make the following model:
max vi                                  Objective
Sv = 0                                  b = np.repeat(0,stoichiometry.shape[0])
vopt-growth ≤ vgrowth ≤ vopt-growth     Bound vgrowth to its optimal value
vmin ≤ v ≤ vmax                         Constraints
"""

flux_variability = pd.DataFrame(columns = ['min','max'])

for reaction in stoichiometry.columns:
  new_objective_max = pd.DataFrame(np.repeat(0,stoichiometry.shape[1]), index = stoichiometry.columns)
  new_objective_max.loc[reaction] = -1
  new_objective_min = pd.DataFrame(np.repeat(0,stoichiometry.shape[1]), index = stoichiometry.columns)
  new_objective_min.loc[reaction] = 1
  max = linprog(new_objective_max.values, A_eq = stoichiometry, b_eq = b, bounds = constraints_max_growth, method='highs-ipm')
  if max.status == 4: #try dual simplex solver
    max = linprog(new_objective_max.values, A_eq = stoichiometry, b_eq = b, bounds = constraints_max_growth, method='highs-ds')
  min = linprog(new_objective_min.values, A_eq = stoichiometry, b_eq = b, bounds = constraints_max_growth, method='highs-ipm')
  if min.status == 4:
    min = linprog(new_objective_min.values, A_eq = stoichiometry, b_eq = b, bounds = constraints_max_growth, method='highs-ds')
  if max.status in [2,4]: #unfeasable or numerical problems
    flux_variability.loc[reaction,'max'] = 'infeasable'
  else:
    flux_variability.loc[reaction,'max'] = -max.fun
  if min.status in [2,4]: #unfeasable or numerical problems
    flux_variability.loc[reaction,'min'] = 'infeasable'
  else:
    flux_variability.loc[reaction,'min'] = min.fun

"""Now let's analyze the results.

1. Plot flux variability results with the names of the reactions on the y-axis and the lower and upper value of their flux on the x-axis. Look at Figure 19 of the syllabus for reference. Only plot the reactions with a span (max $\neq$ min).
2. Next, only plot the reactions that were promising drug targets from the previous exercise. Is it clear from their flux variability that there were drug target? Test this by comparing them with reactions that were active in the reference simulation but did not lead to lethality when deleted.

Tip: use matplotlib 'barh' function, and look up its 'left' parameter
"""

with_span = flux_variability[flux_variability['max'] != flux_variability['min']].index

to_plot = lethal_idx
to_plot = [x for x in to_plot if flux_variability.loc[x,'max'] != 'infeasable' and flux_variability.loc[x,'min'] != 'infeasable']
import matplotlib.pyplot as plt

plt.figure(figsize = (20,200))

plt.barh(to_plot, flux_variability.loc[to_plot,'max'], left=flux_variability.loc[to_plot,'min'], linewidth=2, edgecolor='black')
plt.axvline(0, color='red', linestyle='dashed')
plt.xlim(-10,10) # Some fluxes are to big

plt.show()
